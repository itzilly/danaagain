
--- O:\C++ Programming\GoofyMultiplayerGame\client\game.cpp ---
#include <game.h>

#include <raylib.h>
#include <algorithm>

#include "picojson.h"
#include <fstream>
#include <sstream>
#include <iostream>


GameWindow::GameWindow() noexcept {
    frameRate = 60;
    width = DEFAULT_WINDOW_WIDTH;
    height = DEFAULT_WINDOW_HEIGHT;
    title = WINDOW_TITLE;
    
    InitWindow(width, height, title);
    SetTargetFPS(frameRate);
}

GameWindow::~GameWindow() noexcept {
    CloseWindow();
}


Scene SceneLoader::loadScene(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Failed to open scene file: " << filePath << std::endl;
        return Scene();  // Return an empty scene on failure
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    file.close();

    picojson::value v;
    std::string err = picojson::parse(v, buffer.str());
    if (!err.empty()) {
        std::cerr << "JSON parse error: " << err << std::endl;
        return Scene();  // Return an empty scene on parse error
    }

    Scene scene;

    // Parse the scene object
    picojson::object& sceneObj = v.get<picojson::object>();

    // Parse entities
    picojson::array& entities = sceneObj["entities"].get<picojson::array>();
    for (picojson::array::iterator it = entities.begin(); it != entities.end(); ++it) {
        picojson::object& entityObj = it->get<picojson::object>();
        std::string type = entityObj["type"].get<std::string>();

        if (type == "TextEntity") {
            std::string text = entityObj["text"].get<std::string>();
            picojson::object& positionObj = entityObj["position"].get<picojson::object>();
            EVec position = { float(positionObj["x"].get<double>()), float(positionObj["y"].get<double>()) };

            picojson::object& colorObj = entityObj["color"].get<picojson::object>();
            PlayerColor color = { uint8_t(colorObj["r"].get<double>()), uint8_t(colorObj["g"].get<double>()),
                                  uint8_t(colorObj["b"].get<double>()), uint8_t(colorObj["a"].get<double>()) };

            auto entity = std::make_unique<TextEntity>(text, position, color);
            scene.addEntity(std::move(entity));
        }
        // Add more entity types as needed
    }

    return scene;
}

void SceneLoader::saveScene(const Scene& scene, const std::string& filePath) {
    picojson::object sceneObj;

    // Serialize entities
    picojson::array entitiesArray;
    for (const auto& entity : scene.getAllEntities()) {
        picojson::object entityObj;
        if (auto textEntity = dynamic_cast<TextEntity*>(entity.get())) {
            entityObj["type"] = picojson::value("TextEntity");
            entityObj["text"] = picojson::value(textEntity->getText());

            picojson::object positionObj;
            positionObj["x"] = picojson::value(static_cast<double>(textEntity->getPosition().x));
            positionObj["y"] = picojson::value(static_cast<double>(textEntity->getPosition().y));
            entityObj["position"] = picojson::value(positionObj);

            picojson::object colorObj;
            colorObj["r"] = picojson::value(static_cast<double>(textEntity->getColor().r));
            colorObj["g"] = picojson::value(static_cast<double>(textEntity->getColor().g));
            colorObj["b"] = picojson::value(static_cast<double>(textEntity->getColor().b));
            colorObj["a"] = picojson::value(static_cast<double>(textEntity->getColor().a));
            entityObj["color"] = picojson::value(colorObj);
        }
        // Add more entity types as needed

        entitiesArray.push_back(picojson::value(entityObj));
    }

    sceneObj["entities"] = picojson::value(entitiesArray);

    // Write JSON to file
    std::ofstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Failed to open scene file for writing: " << filePath << std::endl;
        return;
    }

    picojson::value v(sceneObj);
    file << v.serialize(true);  // Pretty-print with indent
    file.close();
}


PlayerEntityObject::PlayerEntityObject(EVec position, PlayerColor playerColor, float playerHealth)
    : pos(position), color(playerColor), health(playerHealth) {}

void PlayerEntityObject::Update() {
    // Implement update logic here
}

void PlayerEntityObject::Render() {
    // Implement render logic here
    DrawCircle(pos.x, pos.y, 20, { color.r, color.g, color.b, color.a });
}

Scene::Scene() {
    // Scene constructor implementation
}

void Scene::addEntity(std::unique_ptr<SceneEntity> entity) {
    entities.push_back(std::move(entity));
}

void Scene::removeEntity(const SceneEntity& entity) {
    entities.erase(std::remove_if(entities.begin(), entities.end(),
        [&entity](const std::unique_ptr<SceneEntity>& ptr) { return ptr.get() == &entity; }),
        entities.end());
}

const std::vector<std::unique_ptr<SceneEntity>>& Scene::getAllEntities() const {
    return entities;
}

SceneManager::SceneManager() : currentScene() {
    // Explicitly initialize currentScene using Scene's constructor
}

SceneManager::~SceneManager() {
    // Destructor (if needed for cleanup)
}

Scene& SceneManager::getScene() {
    return currentScene;
}


LogLevel GameLogger::getLogLevel() {
    return logLevel;
}

void GameLogger::setLogLevel(LogLevel level) {
    logLevel = level;
}

void GameLogger::Log(std::string msg) {
    Log(logLevel, msg);
}

void GameLogger::Log(LogLevel level, std::string msg) {
    switch (level) {
        case DEBUG: 
            TraceLog(LOG_DEBUG, msg.c_str());
            break;
        case WARNING:
            TraceLog(LOG_WARNING, msg.c_str());
            break;
        case INFO:
            TraceLog(LOG_INFO, msg.c_str());
            break;
        case ERROR:
            TraceLog(LOG_ERROR, msg.c_str());
            break;
        case CRITICAL:
            TraceLog(LOG_FATAL, msg.c_str());
            break;
    }
}


Game::Game() : gameWindow(), gameState(), sceneManager(), playerState(), gameLogger(),
      playerEntity("Player", generateRandomPlayerColor(), EVec{0, 0}, 1.0f, Inventory(9, 3)) {
}

int Game::Start() {
    while (!WindowShouldClose()) {
        // Update game state
        if (!sceneManager.getScene().getAllEntities().empty()) {
            sceneManager.getScene().getAllEntities().at(0)->Update();
        }

        // Begin drawing
        BeginDrawing();
        ClearBackground(RAYWHITE);

        // Render game scene
        if (!sceneManager.getScene().getAllEntities().empty()) {
            sceneManager.getScene().getAllEntities().at(0)->Render();
        }

        EndDrawing();
    }

    return 0;
}

PlayerEntity& Game::getPlayerEntity() {
    return playerEntity;
}

GameState& Game::getGameState() {
    return gameState;
}

PlayerState& Game::getPlayerState() {
    return playerState;
}

// picojson::value TextEntity::toJson() const {
//     picojson::object obj;
//     obj["type"] = picojson::value("TextEntity");
//     obj["text"] = picojson::value(text);
//     obj["position"] = picojson::value(picojson::object{
//         {"x", picojson::value(position.x)},
//         {"y", picojson::value(position.y)}
//     });
//     obj["color"] = picojson::value(picojson::object{
//         {"r", picojson::value(static_cast<double>(color.r))},
//         {"g", picojson::value(static_cast<double>(color.g))},
//         {"b", picojson::value(static_cast<double>(color.b))},
//         {"a", picojson::value(static_cast<double>(color.a))}
//     });
//     return picojson::value(obj);
// }

std::unique_ptr<TextEntity> TextEntity::fromJson(const picojson::object& obj) {
    std::string text = obj.at("text").get<std::string>();
    const auto& posObj = obj.at("position").get<picojson::object>();
    EVec position = {
        static_cast<float>(posObj.at("x").get<double>()),
        static_cast<float>(posObj.at("y").get<double>())
    };
    const auto& colorObj = obj.at("color").get<picojson::object>();
    PlayerColor color = {
        static_cast<uint8_t>(colorObj.at("r").get<double>()),
        static_cast<uint8_t>(colorObj.at("g").get<double>()),
        static_cast<uint8_t>(colorObj.at("b").get<double>()),
        static_cast<uint8_t>(colorObj.at("a").get<double>())
    };
    return std::make_unique<TextEntity>(text, position, color);
}

EVec TextEntity::getPosition() {
    return position;
}

std::string TextEntity::getText() {
    return text;
}

Color TextEntity::getColor() {
    return color;
}
END --- O:\C++ Programming\GoofyMultiplayerGame\client\game.cpp

--- O:\C++ Programming\GoofyMultiplayerGame\client\game.h ---
#pragma once

#include <raylib.h>
#include <engine.h>
#include <picojson.h>

#define DEFAULT_WINDOW_WIDTH 1920
#define DEFAULT_WINDOW_HEIGHT 1080
#define WINDOW_TITLE "Multiplayer Networking"


class SceneEntity {
public:
    virtual void Update() = 0;
    virtual void Render() = 0;
    
    virtual ~SceneEntity() = default;
};

class PlayerEntityObject : public SceneEntity {
private:
    EVec pos;
    PlayerColor color;
    float health;

public:
    PlayerEntityObject(EVec position, PlayerColor playerColor, float playerHealth);

    void Update() override;
    void Render() override;
};

class Scene {
private:
    std::vector<std::unique_ptr<SceneEntity>> entities;

public:
    Scene();
    void addEntity(std::unique_ptr<SceneEntity> entity);
    void removeEntity(const SceneEntity& entity);
    const std::vector<std::unique_ptr<SceneEntity>>& getAllEntities() const;
};

class SceneManager {
private:
    Scene currentScene;

public:
    SceneManager();
    ~SceneManager();
    Scene& getScene();
};

class SceneLoader {
public:
    static Scene loadScene(const std::string& filePath);
    static void saveScene(const Scene& scene, const std::string& filePath);
};

/// @brief Represents the game window's properties.
class GameWindow {
private:
    int frameRate;      // The frame rate of the game window.
    int width;          // The width of the game window.
    int height;         // The height of the game window.
    const char* title;  // The title of the game window.

public:
    int getFrameRate() const;

    void setFrameRate(int frameRate);

    int getWidth() const;

    void setWidth(int width);

    int getHeight() const;

    void setHeight(int height);

    const char* getTitle() const;

    void setTitle(const char* title);

    GameWindow() noexcept;
    ~GameWindow() noexcept;
};

/// @brief Defines various log levels for game logging.
typedef enum {
    DEBUG = 0,       // Debugging information.
    WARNING = 10,    // Warnings about potential issues.
    INFO = 20,       // Informational messages.
    ERROR = 30,      // Error messages.
    CRITICAL = 40,   // Critical issues that may halt the game.
} LogLevel;

/// @brief Provides logging functionalities for the game.
class GameLogger {
private:
    LogLevel logLevel; ///< The current logging level.

public:
    /// @brief Gets the current logging level.
    /// @return The current LogLevel.
    LogLevel getLogLevel();

    /// @brief Sets the logging level.
    /// @param level The LogLevel to set.
    void setLogLevel(LogLevel level);

    /// @brief Logs a message with the current logging level.
    /// @param msg The message to log.
    void Log(std::string msg);

    /// @brief Logs a message with a specific logging level.
    /// @param level The LogLevel for the message.
    /// @param msg The message to log.
    void Log(LogLevel level, std::string msg);
};

/// @brief Represents the main game class that manages game state, player, and other components.
class Game {
private:
    GameWindow gameWindow;      // The game window properties.
    PlayerEntity playerEntity;  // The player entity.
    GameState gameState;        // The current state of the game.
    SceneManager sceneManager;  // Manages scenes in the game.
    PlayerState playerState;    // The current state of the player.
    GameLogger gameLogger;      // Handles game logging.

public:
    /// @brief Starts the game loop.
    /// @return An integer representing the exit status of the game.
    int Start();

    /// @brief Gets the player entity.
    /// @return A reference to the PlayerEntity.
    PlayerEntity& getPlayerEntity();

    /// @brief Gets the current game state.
    /// @return A reference to the GameState.
    GameState& getGameState();

    /// @brief Gets the current player state.
    /// @return A reference to the PlayerState.
    PlayerState& getPlayerState();

    /// @brief Gets the singleton instance of the Game.
    /// @return A reference to the singleton Game instance.
    inline static Game& getInstance() {
        static Game instance;
        return instance;
    }

    /// @brief Deleted copy constructor to prevent copying.
    Game(Game const&) = delete;

    /// @brief Deleted assignment operator to prevent assignment.
    void operator=(Game const&) = delete;

private:
    /// @brief Private constructor for singleton pattern.
    Game();
};


class TextEntity : public SceneEntity {
private:
    std::string text;
    EVec position;
    Color color;

public:
    TextEntity(const std::string& text, const EVec& position, const Color& color)
        : text(text), position(position), color(color) {}

    void Update() override {
        // Update logic
    }

    void Render() override {
        // Render logic
    }

    EVec getPosition();
    std::string getText();
    Color getColor();

    static std::unique_ptr<TextEntity> fromJson(const picojson::object& obj);
};
END --- O:\C++ Programming\GoofyMultiplayerGame\client\game.h

--- O:\C++ Programming\GoofyMultiplayerGame\client\main.cpp ---
#include "game.h"

int main() {
    return Game::getInstance().Start();
}

END --- O:\C++ Programming\GoofyMultiplayerGame\client\main.cpp

--- O:\C++ Programming\GoofyMultiplayerGame\client\net_client.cpp ---

END --- O:\C++ Programming\GoofyMultiplayerGame\client\net_client.cpp

--- O:\C++ Programming\GoofyMultiplayerGame\client\net_client.h ---

END --- O:\C++ Programming\GoofyMultiplayerGame\client\net_client.h

--- O:\C++ Programming\GoofyMultiplayerGame\engine\engine.cpp ---
#include <engine.h>

#include <random>

PlayerColor generateRandomPlayerColor() {
    std::random_device randomDevice;
    // Use Mersenne Twister engine for generating random numbers
    std::mt19937 gen(randomDevice());
    std::uniform_int_distribution<std::mt19937::result_type> dist(0, 255);

    PlayerColor randomColor;
    randomColor.r = dist(gen);
    randomColor.g = dist(gen);
    randomColor.b = dist(gen);
    randomColor.a = 255; // Player colors can't be transparent.

    return randomColor;
}

std::string PlayerEntity::getName() const {
    return name;
}

const char* PlayerEntity::getNameCStr() const {
    return name.c_str();
}

PlayerColor PlayerEntity::getColor() const {
    return color;
}

void PlayerEntity::setColor(const PlayerColor& c) {
    color = c;
}

EVec PlayerEntity::getPos() const {
    return pos;
}

void PlayerEntity::setPos(const EVec& vec) {
    pos = vec;
}

float PlayerEntity::getHealth() const {
    return health;
}

void PlayerEntity::setHealth(float h) {
    health = h;
}

Inventory PlayerEntity::getInventory() {
    return inventory;
}

void PlayerEntity::move(const EVec& vec) {
    pos = Lerp(pos, vec, 0.1f);  // Smooth out movement using interpolation
}

bool PlayerEntity::takeDamage(float amount) {
    health -= amount;
    if (health <= 0.0f) {
        health = 0.0f;
        return true;
    }
    return false;
}


EVec Lerp(const EVec& start, const EVec& end, float t) {
    EVec result;
    result.x = start.x + t * (end.x - start.x);
    result.y = start.y + t * (end.y - start.y);
    return result;
}



END --- O:\C++ Programming\GoofyMultiplayerGame\engine\engine.cpp

--- O:\C++ Programming\GoofyMultiplayerGame\engine\include\engine.h ---
#pragma once

#include <string>
#include <vector>

/// @brief Represent the state of the server.
typedef enum {
    STARTING = 0,   // The server is starting up. No client connections are allowed.
    OPEN = 1,       // The server is open and accepting client connections.
    CLOSING = 2     // The server is closing and therefor disconnecting all clients.
} ServerState;

/// @brief Represents the state of the game.
typedef enum {
    MENU = 0,        // The game is in the menu state.
    CONNECTING = 1,  // The game is trying to connect to a server.
    PLAYING = 2,     // The game is currently being played.
} GameState;

/// @brief Represents the state of a player.
typedef enum {
    SYNCING = 0,         // The player is syncing data with the server.
    LOADING = 1,         // The player is loading into the world.
    NORMAL = 2,          // The player is actively engaged in gameplay, without any menus or overlays open.
    CHAT = 3,            // The player has the chat opened.
    INVENTORY = 4,       // The player has their inventory open.
    CRAFTING = 5,        // The player is in a crafting gui.
    OPEN_CONTAINER = 6,  // The player is viewing the contents of a container.
} PlayerState;

/// @brief Represents a player's color.
/// @note This is designed to be able to be switched
/// out for raylib's color type in the future.
typedef struct {
    unsigned char r;  // Red component (0-255)
    unsigned char g;  // Green component (0-255)
    unsigned char b;  // Blue component (0-255)
    unsigned char a;  // Alpha component (0-255, transparency)
} PlayerColor;

/// @brief Represents color
/// @note This is designed to be able to be switched
/// out for raylib's color type in the future.
typedef struct {
    unsigned char r;  // Red component (0-255)
    unsigned char g;  // Green component (0-255)
    unsigned char b;  // Blue component (0-255)
    unsigned char a;  // Alpha component (0-255, transparency)
} ColorR;

/// @brief Generates a random color.
/// @note The a value will always be 0 since player's can't be transparent.
/// @return A PlayerColor with random r, g, and b values.
PlayerColor generateRandomPlayerColor();

/// @brief Represents a 2D vector.
/// This is designed to be a 'wrapper' around 
/// raylib's vector type since including raylib
/// and networking together in the same file doesn't work.
typedef struct {
    float x;  // x coordinate of the vector
    float y;  // y coordinate of the vector
} EVec;

/// @brief Represents an inventory item.
/// @warning This will be deprecated in future
/// versions in favor of a class/object instead
/// of a struct.
typedef struct {
    std::string name;      // The name of the item.
    int maxStackSize;      // The maximum number of items that can be stacked.
    int amount;            // The current amount of this item in the stack.
} InventoryItem_s;

/// @brief Represents the inventory of a player or entity or container.
class Inventory {
public:
    /// @brief A vector containing all items in the inventory.
    std::vector<InventoryItem_s> items;

    /// @brief The number of rows in the inventory grid.
    int rows;

    /// @brief The number of columns in the inventory grid.
    int cols;

    /// @brief Constructs an Inventory with a specified number of rows and columns.
    /// @param r The number of rows in the inventory.
    /// @param c The number of columns in the inventory.
    Inventory(int r, int c) : rows(r), cols(c), items() {}
};

/// @brief Represents a player entity.
class PlayerEntity {
private:
    /// @brief The name of the player.
    std::string name;

    /// @brief The color representing the player.
    PlayerColor color;

    /// @brief The current position of the player in the game world.
    EVec pos;

    /// @brief The current health of the player.
    float health;

    /// @brief The player's inventory.
    Inventory inventory;

public:
    /// @brief Gets the player's name.
    /// @return The name of the player as a std::string.
    std::string getName() const;

    /// @brief Gets the player's name as a C-style string.
    /// @return The name of the player as a const char*.
    const char* getNameCStr() const;

    /// @brief Sets the player's color.
    /// @param color The color to set for the player.
    void setColor(const PlayerColor& color);

    /// @brief Gets the player's color.
    /// @return The player color as a PlayerColor (not Raylib Color)
    PlayerColor getColor() const;

    /// @brief Gets the world position of the player.
    /// @return The player's position as an EVec.
    EVec getPos() const;

    /// @brief Sets the player's position.
    /// @param vec The new position for the player.
    void setPos(const EVec& vec);

    /// @brief Gets the player's current health.
    /// @return The current health of the player as a float.
    float getHealth() const;

    /// @brief Sets the player's health.
    /// @param health The new health value for the player.
    void setHealth(float health);

    /// @brief Gets the player's inventory.
    /// @return The current inventory of the player as Inventory.
    Inventory getInventory();

    /// @brief Moves the player by a given vector.
    /// @param vec The vector by which to move the player.
    void move(const EVec& vec);
    
    /// @brief Damages the player by a given amount.
    /// @param amount The amount to reduce the player's health by.
    /// @return Returns true if the player dies after taking the damage, false otherwise.
    bool takeDamage(float amount);
    
    /// @brief Constructs a PlayerEntity.
    /// @param name The name of the player.
    /// @param color The color of the player.
    /// @param pos The world position of the player.
    /// @param health The health of the player.
    PlayerEntity(std::string name, PlayerColor color, EVec pos, float health, Inventory inventory) : name(name), color(color), pos(pos), health(health), inventory(std::move(inventory)) {};
};

EVec Lerp(const EVec& start, const EVec& end, float t);

//class Client {
//private:
//    Client() {}
//
//    PlayerEntity playerEntity;
//
//public:
//    PlayerEntity getPlayerEntity();
//};



END --- O:\C++ Programming\GoofyMultiplayerGame\engine\include\engine.h

--- O:\C++ Programming\GoofyMultiplayerGame\engine\include\picojson.h ---
/*
 * Copyright 2009-2010 Cybozu Labs, Inc.
 * Copyright 2011-2014 Kazuho Oku
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef picojson_h
#define picojson_h

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstddef>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <stdexcept>
#include <string>
#include <vector>
#include <utility>

// for isnan/isinf
#if __cplusplus >= 201103L
#include <cmath>
#else
extern "C" {
#ifdef _MSC_VER
#include <float.h>
#elif defined(__INTEL_COMPILER)
#include <mathimf.h>
#else
#include <math.h>
#endif
}
#endif

#ifndef PICOJSON_USE_RVALUE_REFERENCE
#if (defined(__cpp_rvalue_references) && __cpp_rvalue_references >= 200610) || (defined(_MSC_VER) && _MSC_VER >= 1600)
#define PICOJSON_USE_RVALUE_REFERENCE 1
#else
#define PICOJSON_USE_RVALUE_REFERENCE 0
#endif
#endif // PICOJSON_USE_RVALUE_REFERENCE

#ifndef PICOJSON_NOEXCEPT
#if PICOJSON_USE_RVALUE_REFERENCE
#define PICOJSON_NOEXCEPT noexcept
#else
#define PICOJSON_NOEXCEPT throw()
#endif
#endif

// experimental support for int64_t (see README.mkdn for detail)
#ifdef PICOJSON_USE_INT64
#define __STDC_FORMAT_MACROS
#include <cerrno>
#if __cplusplus >= 201103L
#include <cinttypes>
#else
extern "C" {
#include <inttypes.h>
}
#endif
#endif

// to disable the use of localeconv(3), set PICOJSON_USE_LOCALE to 0
#ifndef PICOJSON_USE_LOCALE
#define PICOJSON_USE_LOCALE 1
#endif
#if PICOJSON_USE_LOCALE
extern "C" {
#include <locale.h>
}
#endif

#ifndef PICOJSON_ASSERT
#define PICOJSON_ASSERT(e)                                                                                                         \
  do {                                                                                                                             \
    if (!(e))                                                                                                                      \
      throw std::runtime_error(#e);                                                                                                \
  } while (0)
#endif

#ifdef _MSC_VER
#define SNPRINTF _snprintf_s
#pragma warning(push)
#pragma warning(disable : 4244) // conversion from int to char
#pragma warning(disable : 4127) // conditional expression is constant
#pragma warning(disable : 4702) // unreachable code
#pragma warning(disable : 4706) // assignment within conditional expression
#else
#define SNPRINTF snprintf
#endif

namespace picojson {

enum {
  null_type,
  boolean_type,
  number_type,
  string_type,
  array_type,
  object_type
#ifdef PICOJSON_USE_INT64
  ,
  int64_type
#endif
};

enum { INDENT_WIDTH = 2, DEFAULT_MAX_DEPTHS = 100 };

struct null {};

class value {
public:
  typedef std::vector<value> array;
  typedef std::map<std::string, value> object;
  union _storage {
    bool boolean_;
    double number_;
#ifdef PICOJSON_USE_INT64
    int64_t int64_;
#endif
    std::string *string_;
    array *array_;
    object *object_;
  };

protected:
  int type_;
  _storage u_;

public:
  value();
  value(int type, bool);
  explicit value(bool b);
#ifdef PICOJSON_USE_INT64
  explicit value(int64_t i);
#endif
  explicit value(double n);
  explicit value(const std::string &s);
  explicit value(const array &a);
  explicit value(const object &o);
#if PICOJSON_USE_RVALUE_REFERENCE
  explicit value(std::string &&s);
  explicit value(array &&a);
  explicit value(object &&o);
#endif
  explicit value(const char *s);
  value(const char *s, size_t len);
  ~value();
  value(const value &x);
  value &operator=(const value &x);
#if PICOJSON_USE_RVALUE_REFERENCE
  value(value &&x) PICOJSON_NOEXCEPT;
  value &operator=(value &&x) PICOJSON_NOEXCEPT;
#endif
  void swap(value &x) PICOJSON_NOEXCEPT;
  template <typename T> bool is() const;
  template <typename T> const T &get() const;
  template <typename T> T &get();
  template <typename T> void set(const T &);
#if PICOJSON_USE_RVALUE_REFERENCE
  template <typename T> void set(T &&);
#endif
  bool evaluate_as_boolean() const;
  const value &get(const size_t idx) const;
  const value &get(const std::string &key) const;
  value &get(const size_t idx);
  value &get(const std::string &key);

  bool contains(const size_t idx) const;
  bool contains(const std::string &key) const;
  std::string to_str() const;
  template <typename Iter> void serialize(Iter os, bool prettify = false) const;
  std::string serialize(bool prettify = false) const;

private:
  template <typename T> value(const T *); // intentionally defined to block implicit conversion of pointer to bool
  template <typename Iter> static void _indent(Iter os, int indent);
  template <typename Iter> void _serialize(Iter os, int indent) const;
  std::string _serialize(int indent) const;
  void clear();
};

typedef value::array array;
typedef value::object object;

inline value::value() : type_(null_type), u_() {
}

inline value::value(int type, bool) : type_(type), u_() {
  switch (type) {
#define INIT(p, v)                                                                                                                 \
  case p##type:                                                                                                                    \
    u_.p = v;                                                                                                                      \
    break
    INIT(boolean_, false);
    INIT(number_, 0.0);
#ifdef PICOJSON_USE_INT64
    INIT(int64_, 0);
#endif
    INIT(string_, new std::string());
    INIT(array_, new array());
    INIT(object_, new object());
#undef INIT
  default:
    break;
  }
}

inline value::value(bool b) : type_(boolean_type), u_() {
  u_.boolean_ = b;
}

#ifdef PICOJSON_USE_INT64
inline value::value(int64_t i) : type_(int64_type), u_() {
  u_.int64_ = i;
}
#endif

inline value::value(double n) : type_(number_type), u_() {
  if (
#ifdef _MSC_VER
      !_finite(n)
#elif __cplusplus >= 201103L
      std::isnan(n) || std::isinf(n)
#else
      isnan(n) || isinf(n)
#endif
          ) {
    throw std::overflow_error("");
  }
  u_.number_ = n;
}

inline value::value(const std::string &s) : type_(string_type), u_() {
  u_.string_ = new std::string(s);
}

inline value::value(const array &a) : type_(array_type), u_() {
  u_.array_ = new array(a);
}

inline value::value(const object &o) : type_(object_type), u_() {
  u_.object_ = new object(o);
}

#if PICOJSON_USE_RVALUE_REFERENCE
inline value::value(std::string &&s) : type_(string_type), u_() {
  u_.string_ = new std::string(std::move(s));
}

inline value::value(array &&a) : type_(array_type), u_() {
  u_.array_ = new array(std::move(a));
}

inline value::value(object &&o) : type_(object_type), u_() {
  u_.object_ = new object(std::move(o));
}
#endif

inline value::value(const char *s) : type_(string_type), u_() {
  u_.string_ = new std::string(s);
}

inline value::value(const char *s, size_t len) : type_(string_type), u_() {
  u_.string_ = new std::string(s, len);
}

inline void value::clear() {
  switch (type_) {
#define DEINIT(p)                                                                                                                  \
  case p##type:                                                                                                                    \
    delete u_.p;                                                                                                                   \
    break
    DEINIT(string_);
    DEINIT(array_);
    DEINIT(object_);
#undef DEINIT
  default:
    break;
  }
}

inline value::~value() {
  clear();
}

inline value::value(const value &x) : type_(x.type_), u_() {
  switch (type_) {
#define INIT(p, v)                                                                                                                 \
  case p##type:                                                                                                                    \
    u_.p = v;                                                                                                                      \
    break
    INIT(string_, new std::string(*x.u_.string_));
    INIT(array_, new array(*x.u_.array_));
    INIT(object_, new object(*x.u_.object_));
#undef INIT
  default:
    u_ = x.u_;
    break;
  }
}

inline value &value::operator=(const value &x) {
  if (this != &x) {
    value t(x);
    swap(t);
  }
  return *this;
}

#if PICOJSON_USE_RVALUE_REFERENCE
inline value::value(value &&x) PICOJSON_NOEXCEPT : type_(null_type), u_() {
  swap(x);
}
inline value &value::operator=(value &&x) PICOJSON_NOEXCEPT {
  swap(x);
  return *this;
}
#endif
inline void value::swap(value &x) PICOJSON_NOEXCEPT {
  std::swap(type_, x.type_);
  std::swap(u_, x.u_);
}

#define IS(ctype, jtype)                                                                                                           \
  template <> inline bool value::is<ctype>() const {                                                                               \
    return type_ == jtype##_type;                                                                                                  \
  }
IS(null, null)
IS(bool, boolean)
#ifdef PICOJSON_USE_INT64
IS(int64_t, int64)
#endif
IS(std::string, string)
IS(array, array)
IS(object, object)
#undef IS
template <> inline bool value::is<double>() const {
  return type_ == number_type
#ifdef PICOJSON_USE_INT64
         || type_ == int64_type
#endif
      ;
}

#define GET(ctype, var)                                                                                                            \
  template <> inline const ctype &value::get<ctype>() const {                                                                      \
    PICOJSON_ASSERT("type mismatch! call is<type>() before get<type>()" && is<ctype>());                                           \
    return var;                                                                                                                    \
  }                                                                                                                                \
  template <> inline ctype &value::get<ctype>() {                                                                                  \
    PICOJSON_ASSERT("type mismatch! call is<type>() before get<type>()" && is<ctype>());                                           \
    return var;                                                                                                                    \
  }
GET(bool, u_.boolean_)
GET(std::string, *u_.string_)
GET(array, *u_.array_)
GET(object, *u_.object_)
#ifdef PICOJSON_USE_INT64
GET(double,
    (type_ == int64_type && (const_cast<value *>(this)->type_ = number_type, (const_cast<value *>(this)->u_.number_ = u_.int64_)),
     u_.number_))
GET(int64_t, u_.int64_)
#else
GET(double, u_.number_)
#endif
#undef GET

#define SET(ctype, jtype, setter)                                                                                                  \
  template <> inline void value::set<ctype>(const ctype &_val) {                                                                   \
    clear();                                                                                                                       \
    type_ = jtype##_type;                                                                                                          \
    setter                                                                                                                         \
  }
SET(bool, boolean, u_.boolean_ = _val;)
SET(std::string, string, u_.string_ = new std::string(_val);)
SET(array, array, u_.array_ = new array(_val);)
SET(object, object, u_.object_ = new object(_val);)
SET(double, number, u_.number_ = _val;)
#ifdef PICOJSON_USE_INT64
SET(int64_t, int64, u_.int64_ = _val;)
#endif
#undef SET

#if PICOJSON_USE_RVALUE_REFERENCE
#define MOVESET(ctype, jtype, setter)                                                                                              \
  template <> inline void value::set<ctype>(ctype && _val) {                                                                       \
    clear();                                                                                                                       \
    type_ = jtype##_type;                                                                                                          \
    setter                                                                                                                         \
  }
MOVESET(std::string, string, u_.string_ = new std::string(std::move(_val));)
MOVESET(array, array, u_.array_ = new array(std::move(_val));)
MOVESET(object, object, u_.object_ = new object(std::move(_val));)
#undef MOVESET
#endif

inline bool value::evaluate_as_boolean() const {
  switch (type_) {
  case null_type:
    return false;
  case boolean_type:
    return u_.boolean_;
  case number_type:
    return u_.number_ != 0;
#ifdef PICOJSON_USE_INT64
  case int64_type:
    return u_.int64_ != 0;
#endif
  case string_type:
    return !u_.string_->empty();
  default:
    return true;
  }
}

inline const value &value::get(const size_t idx) const {
  static value s_null;
  PICOJSON_ASSERT(is<array>());
  return idx < u_.array_->size() ? (*u_.array_)[idx] : s_null;
}

inline value &value::get(const size_t idx) {
  static value s_null;
  PICOJSON_ASSERT(is<array>());
  return idx < u_.array_->size() ? (*u_.array_)[idx] : s_null;
}

inline const value &value::get(const std::string &key) const {
  static value s_null;
  PICOJSON_ASSERT(is<object>());
  object::const_iterator i = u_.object_->find(key);
  return i != u_.object_->end() ? i->second : s_null;
}

inline value &value::get(const std::string &key) {
  static value s_null;
  PICOJSON_ASSERT(is<object>());
  object::iterator i = u_.object_->find(key);
  return i != u_.object_->end() ? i->second : s_null;
}

inline bool value::contains(const size_t idx) const {
  PICOJSON_ASSERT(is<array>());
  return idx < u_.array_->size();
}

inline bool value::contains(const std::string &key) const {
  PICOJSON_ASSERT(is<object>());
  object::const_iterator i = u_.object_->find(key);
  return i != u_.object_->end();
}

inline std::string value::to_str() const {
  switch (type_) {
  case null_type:
    return "null";
  case boolean_type:
    return u_.boolean_ ? "true" : "false";
#ifdef PICOJSON_USE_INT64
  case int64_type: {
    char buf[sizeof("-9223372036854775808")];
    SNPRINTF(buf, sizeof(buf), "%" PRId64, u_.int64_);
    return buf;
  }
#endif
  case number_type: {
    char buf[256];
    double tmp;
    SNPRINTF(buf, sizeof(buf), fabs(u_.number_) < (1ULL << 53) && modf(u_.number_, &tmp) == 0 ? "%.f" : "%.17g", u_.number_);
#if PICOJSON_USE_LOCALE
    char *decimal_point = localeconv()->decimal_point;
    if (strcmp(decimal_point, ".") != 0) {
      size_t decimal_point_len = strlen(decimal_point);
      for (char *p = buf; *p != '\0'; ++p) {
        if (strncmp(p, decimal_point, decimal_point_len) == 0) {
          return std::string(buf, p) + "." + (p + decimal_point_len);
        }
      }
    }
#endif
    return buf;
  }
  case string_type:
    return *u_.string_;
  case array_type:
    return "array";
  case object_type:
    return "object";
  default:
    PICOJSON_ASSERT(0);
#ifdef _MSC_VER
    __assume(0);
#endif
  }
  return std::string();
}

template <typename Iter> void copy(const std::string &s, Iter oi) {
  std::copy(s.begin(), s.end(), oi);
}

template <typename Iter> struct serialize_str_char {
  Iter oi;
  void operator()(char c) {
    switch (c) {
#define MAP(val, sym)                                                                                                              \
  case val:                                                                                                                        \
    copy(sym, oi);                                                                                                                 \
    break
      MAP('"', "\\\"");
      MAP('\\', "\\\\");
      MAP('/', "\\/");
      MAP('\b', "\\b");
      MAP('\f', "\\f");
      MAP('\n', "\\n");
      MAP('\r', "\\r");
      MAP('\t', "\\t");
#undef MAP
    default:
      if (static_cast<unsigned char>(c) < 0x20 || c == 0x7f) {
        char buf[7];
        SNPRINTF(buf, sizeof(buf), "\\u%04x", c & 0xff);
        copy(buf, buf + 6, oi);
      } else {
        *oi++ = c;
      }
      break;
    }
  }
};

template <typename Iter> void serialize_str(const std::string &s, Iter oi) {
  *oi++ = '"';
  serialize_str_char<Iter> process_char = {oi};
  std::for_each(s.begin(), s.end(), process_char);
  *oi++ = '"';
}

template <typename Iter> void value::serialize(Iter oi, bool prettify) const {
  return _serialize(oi, prettify ? 0 : -1);
}

inline std::string value::serialize(bool prettify) const {
  return _serialize(prettify ? 0 : -1);
}

template <typename Iter> void value::_indent(Iter oi, int indent) {
  *oi++ = '\n';
  for (int i = 0; i < indent * INDENT_WIDTH; ++i) {
    *oi++ = ' ';
  }
}

template <typename Iter> void value::_serialize(Iter oi, int indent) const {
  switch (type_) {
  case string_type:
    serialize_str(*u_.string_, oi);
    break;
  case array_type: {
    *oi++ = '[';
    if (indent != -1) {
      ++indent;
    }
    for (array::const_iterator i = u_.array_->begin(); i != u_.array_->end(); ++i) {
      if (i != u_.array_->begin()) {
        *oi++ = ',';
      }
      if (indent != -1) {
        _indent(oi, indent);
      }
      i->_serialize(oi, indent);
    }
    if (indent != -1) {
      --indent;
      if (!u_.array_->empty()) {
        _indent(oi, indent);
      }
    }
    *oi++ = ']';
    break;
  }
  case object_type: {
    *oi++ = '{';
    if (indent != -1) {
      ++indent;
    }
    for (object::const_iterator i = u_.object_->begin(); i != u_.object_->end(); ++i) {
      if (i != u_.object_->begin()) {
        *oi++ = ',';
      }
      if (indent != -1) {
        _indent(oi, indent);
      }
      serialize_str(i->first, oi);
      *oi++ = ':';
      if (indent != -1) {
        *oi++ = ' ';
      }
      i->second._serialize(oi, indent);
    }
    if (indent != -1) {
      --indent;
      if (!u_.object_->empty()) {
        _indent(oi, indent);
      }
    }
    *oi++ = '}';
    break;
  }
  default:
    copy(to_str(), oi);
    break;
  }
  if (indent == 0) {
    *oi++ = '\n';
  }
}

inline std::string value::_serialize(int indent) const {
  std::string s;
  _serialize(std::back_inserter(s), indent);
  return s;
}

template <typename Iter> class input {
protected:
  Iter cur_, end_;
  bool consumed_;
  int line_;

public:
  input(const Iter &first, const Iter &last) : cur_(first), end_(last), consumed_(false), line_(1) {
  }
  int getc() {
    if (consumed_) {
      if (*cur_ == '\n') {
        ++line_;
      }
      ++cur_;
    }
    if (cur_ == end_) {
      consumed_ = false;
      return -1;
    }
    consumed_ = true;
    return *cur_ & 0xff;
  }
  void ungetc() {
    consumed_ = false;
  }
  Iter cur() const {
    if (consumed_) {
      input<Iter> *self = const_cast<input<Iter> *>(this);
      self->consumed_ = false;
      ++self->cur_;
    }
    return cur_;
  }
  int line() const {
    return line_;
  }
  void skip_ws() {
    while (1) {
      int ch = getc();
      if (!(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')) {
        ungetc();
        break;
      }
    }
  }
  bool expect(const int expected) {
    skip_ws();
    if (getc() != expected) {
      ungetc();
      return false;
    }
    return true;
  }
  bool match(const std::string &pattern) {
    for (std::string::const_iterator pi(pattern.begin()); pi != pattern.end(); ++pi) {
      if (getc() != *pi) {
        ungetc();
        return false;
      }
    }
    return true;
  }
};

template <typename Iter> inline int _parse_quadhex(input<Iter> &in) {
  int uni_ch = 0, hex;
  for (int i = 0; i < 4; i++) {
    if ((hex = in.getc()) == -1) {
      return -1;
    }
    if ('0' <= hex && hex <= '9') {
      hex -= '0';
    } else if ('A' <= hex && hex <= 'F') {
      hex -= 'A' - 0xa;
    } else if ('a' <= hex && hex <= 'f') {
      hex -= 'a' - 0xa;
    } else {
      in.ungetc();
      return -1;
    }
    uni_ch = uni_ch * 16 + hex;
  }
  return uni_ch;
}

template <typename String, typename Iter> inline bool _parse_codepoint(String &out, input<Iter> &in) {
  int uni_ch;
  if ((uni_ch = _parse_quadhex(in)) == -1) {
    return false;
  }
  if (0xd800 <= uni_ch && uni_ch <= 0xdfff) {
    if (0xdc00 <= uni_ch) {
      // a second 16-bit of a surrogate pair appeared
      return false;
    }
    // first 16-bit of surrogate pair, get the next one
    if (in.getc() != '\\' || in.getc() != 'u') {
      in.ungetc();
      return false;
    }
    int second = _parse_quadhex(in);
    if (!(0xdc00 <= second && second <= 0xdfff)) {
      return false;
    }
    uni_ch = ((uni_ch - 0xd800) << 10) | ((second - 0xdc00) & 0x3ff);
    uni_ch += 0x10000;
  }
  if (uni_ch < 0x80) {
    out.push_back(static_cast<char>(uni_ch));
  } else {
    if (uni_ch < 0x800) {
      out.push_back(static_cast<char>(0xc0 | (uni_ch >> 6)));
    } else {
      if (uni_ch < 0x10000) {
        out.push_back(static_cast<char>(0xe0 | (uni_ch >> 12)));
      } else {
        out.push_back(static_cast<char>(0xf0 | (uni_ch >> 18)));
        out.push_back(static_cast<char>(0x80 | ((uni_ch >> 12) & 0x3f)));
      }
      out.push_back(static_cast<char>(0x80 | ((uni_ch >> 6) & 0x3f)));
    }
    out.push_back(static_cast<char>(0x80 | (uni_ch & 0x3f)));
  }
  return true;
}

template <typename String, typename Iter> inline bool _parse_string(String &out, input<Iter> &in) {
  while (1) {
    int ch = in.getc();
    if (ch < ' ') {
      in.ungetc();
      return false;
    } else if (ch == '"') {
      return true;
    } else if (ch == '\\') {
      if ((ch = in.getc()) == -1) {
        return false;
      }
      switch (ch) {
#define MAP(sym, val)                                                                                                              \
  case sym:                                                                                                                        \
    out.push_back(val);                                                                                                            \
    break
        MAP('"', '\"');
        MAP('\\', '\\');
        MAP('/', '/');
        MAP('b', '\b');
        MAP('f', '\f');
        MAP('n', '\n');
        MAP('r', '\r');
        MAP('t', '\t');
#undef MAP
      case 'u':
        if (!_parse_codepoint(out, in)) {
          return false;
        }
        break;
      default:
        return false;
      }
    } else {
      out.push_back(static_cast<char>(ch));
    }
  }
  return false;
}

template <typename Context, typename Iter> inline bool _parse_array(Context &ctx, input<Iter> &in) {
  if (!ctx.parse_array_start()) {
    return false;
  }
  size_t idx = 0;
  if (in.expect(']')) {
    return ctx.parse_array_stop(idx);
  }
  do {
    if (!ctx.parse_array_item(in, idx)) {
      return false;
    }
    idx++;
  } while (in.expect(','));
  return in.expect(']') && ctx.parse_array_stop(idx);
}

template <typename Context, typename Iter> inline bool _parse_object(Context &ctx, input<Iter> &in) {
  if (!ctx.parse_object_start()) {
    return false;
  }
  if (in.expect('}')) {
    return ctx.parse_object_stop();
  }
  do {
    std::string key;
    if (!in.expect('"') || !_parse_string(key, in) || !in.expect(':')) {
      return false;
    }
    if (!ctx.parse_object_item(in, key)) {
      return false;
    }
  } while (in.expect(','));
  return in.expect('}') && ctx.parse_object_stop();
}

template <typename Iter> inline std::string _parse_number(input<Iter> &in) {
  std::string num_str;
  while (1) {
    int ch = in.getc();
    if (('0' <= ch && ch <= '9') || ch == '+' || ch == '-' || ch == 'e' || ch == 'E') {
      num_str.push_back(static_cast<char>(ch));
    } else if (ch == '.') {
#if PICOJSON_USE_LOCALE
      num_str += localeconv()->decimal_point;
#else
      num_str.push_back('.');
#endif
    } else {
      in.ungetc();
      break;
    }
  }
  return num_str;
}

template <typename Context, typename Iter> inline bool _parse(Context &ctx, input<Iter> &in) {
  in.skip_ws();
  int ch = in.getc();
  switch (ch) {
#define IS(ch, text, op)                                                                                                           \
  case ch:                                                                                                                         \
    if (in.match(text) && op) {                                                                                                    \
      return true;                                                                                                                 \
    } else {                                                                                                                       \
      return false;                                                                                                                \
    }
    IS('n', "ull", ctx.set_null());
    IS('f', "alse", ctx.set_bool(false));
    IS('t', "rue", ctx.set_bool(true));
#undef IS
  case '"':
    return ctx.parse_string(in);
  case '[':
    return _parse_array(ctx, in);
  case '{':
    return _parse_object(ctx, in);
  default:
    if (('0' <= ch && ch <= '9') || ch == '-') {
      double f;
      char *endp;
      in.ungetc();
      std::string num_str(_parse_number(in));
      if (num_str.empty()) {
        return false;
      }
#ifdef PICOJSON_USE_INT64
      {
        errno = 0;
        intmax_t ival = strtoimax(num_str.c_str(), &endp, 10);
        if (errno == 0 && std::numeric_limits<int64_t>::min() <= ival && ival <= std::numeric_limits<int64_t>::max() &&
            endp == num_str.c_str() + num_str.size()) {
          ctx.set_int64(ival);
          return true;
        }
      }
#endif
      f = strtod(num_str.c_str(), &endp);
      if (endp == num_str.c_str() + num_str.size()) {
        ctx.set_number(f);
        return true;
      }
      return false;
    }
    break;
  }
  in.ungetc();
  return false;
}

class deny_parse_context {
public:
  bool set_null() {
    return false;
  }
  bool set_bool(bool) {
    return false;
  }
#ifdef PICOJSON_USE_INT64
  bool set_int64(int64_t) {
    return false;
  }
#endif
  bool set_number(double) {
    return false;
  }
  template <typename Iter> bool parse_string(input<Iter> &) {
    return false;
  }
  bool parse_array_start() {
    return false;
  }
  template <typename Iter> bool parse_array_item(input<Iter> &, size_t) {
    return false;
  }
  bool parse_array_stop(size_t) {
    return false;
  }
  bool parse_object_start() {
    return false;
  }
  template <typename Iter> bool parse_object_item(input<Iter> &, const std::string &) {
    return false;
  }
};

class default_parse_context {
protected:
  value *out_;
  size_t depths_;

public:
  default_parse_context(value *out, size_t depths = DEFAULT_MAX_DEPTHS) : out_(out), depths_(depths) {
  }
  bool set_null() {
    *out_ = value();
    return true;
  }
  bool set_bool(bool b) {
    *out_ = value(b);
    return true;
  }
#ifdef PICOJSON_USE_INT64
  bool set_int64(int64_t i) {
    *out_ = value(i);
    return true;
  }
#endif
  bool set_number(double f) {
    *out_ = value(f);
    return true;
  }
  template <typename Iter> bool parse_string(input<Iter> &in) {
    *out_ = value(string_type, false);
    return _parse_string(out_->get<std::string>(), in);
  }
  bool parse_array_start() {
    if (depths_ == 0)
      return false;
    --depths_;
    *out_ = value(array_type, false);
    return true;
  }
  template <typename Iter> bool parse_array_item(input<Iter> &in, size_t) {
    array &a = out_->get<array>();
    a.push_back(value());
    default_parse_context ctx(&a.back(), depths_);
    return _parse(ctx, in);
  }
  bool parse_array_stop(size_t) {
    ++depths_;
    return true;
  }
  bool parse_object_start() {
    if (depths_ == 0)
      return false;
    *out_ = value(object_type, false);
    return true;
  }
  template <typename Iter> bool parse_object_item(input<Iter> &in, const std::string &key) {
    object &o = out_->get<object>();
    default_parse_context ctx(&o[key], depths_);
    return _parse(ctx, in);
  }
  bool parse_object_stop() {
    ++depths_;
    return true;
  }

private:
  default_parse_context(const default_parse_context &);
  default_parse_context &operator=(const default_parse_context &);
};

class null_parse_context {
protected:
  size_t depths_;

public:
  struct dummy_str {
    void push_back(int) {
    }
  };

public:
  null_parse_context(size_t depths = DEFAULT_MAX_DEPTHS) : depths_(depths) {
  }
  bool set_null() {
    return true;
  }
  bool set_bool(bool) {
    return true;
  }
#ifdef PICOJSON_USE_INT64
  bool set_int64(int64_t) {
    return true;
  }
#endif
  bool set_number(double) {
    return true;
  }
  template <typename Iter> bool parse_string(input<Iter> &in) {
    dummy_str s;
    return _parse_string(s, in);
  }
  bool parse_array_start() {
    if (depths_ == 0)
      return false;
    --depths_;
    return true;
  }
  template <typename Iter> bool parse_array_item(input<Iter> &in, size_t) {
    return _parse(*this, in);
  }
  bool parse_array_stop(size_t) {
    ++depths_;
    return true;
  }
  bool parse_object_start() {
    if (depths_ == 0)
      return false;
    --depths_;
    return true;
  }
  template <typename Iter> bool parse_object_item(input<Iter> &in, const std::string &) {
    ++depths_;
    return _parse(*this, in);
  }
  bool parse_object_stop() {
    return true;
  }

private:
  null_parse_context(const null_parse_context &);
  null_parse_context &operator=(const null_parse_context &);
};

// obsolete, use the version below
template <typename Iter> inline std::string parse(value &out, Iter &pos, const Iter &last) {
  std::string err;
  pos = parse(out, pos, last, &err);
  return err;
}

template <typename Context, typename Iter> inline Iter _parse(Context &ctx, const Iter &first, const Iter &last, std::string *err) {
  input<Iter> in(first, last);
  if (!_parse(ctx, in) && err != NULL) {
    char buf[64];
    SNPRINTF(buf, sizeof(buf), "syntax error at line %d near: ", in.line());
    *err = buf;
    while (1) {
      int ch = in.getc();
      if (ch == -1 || ch == '\n') {
        break;
      } else if (ch >= ' ') {
        err->push_back(static_cast<char>(ch));
      }
    }
  }
  return in.cur();
}

template <typename Iter> inline Iter parse(value &out, const Iter &first, const Iter &last, std::string *err) {
  default_parse_context ctx(&out);
  return _parse(ctx, first, last, err);
}

inline std::string parse(value &out, const std::string &s) {
  std::string err;
  parse(out, s.begin(), s.end(), &err);
  return err;
}

inline std::string parse(value &out, std::istream &is) {
  std::string err;
  parse(out, std::istreambuf_iterator<char>(is.rdbuf()), std::istreambuf_iterator<char>(), &err);
  return err;
}

template <typename T> struct last_error_t { static std::string s; };
template <typename T> std::string last_error_t<T>::s;

inline void set_last_error(const std::string &s) {
  last_error_t<bool>::s = s;
}

inline const std::string &get_last_error() {
  return last_error_t<bool>::s;
}

inline bool operator==(const value &x, const value &y) {
  if (x.is<null>())
    return y.is<null>();
#define PICOJSON_CMP(type)                                                                                                         \
  if (x.is<type>())                                                                                                                \
  return y.is<type>() && x.get<type>() == y.get<type>()
  PICOJSON_CMP(bool);
  PICOJSON_CMP(double);
  PICOJSON_CMP(std::string);
  PICOJSON_CMP(array);
  PICOJSON_CMP(object);
#undef PICOJSON_CMP
  PICOJSON_ASSERT(0);
#ifdef _MSC_VER
  __assume(0);
#endif
  return false;
}

inline bool operator!=(const value &x, const value &y) {
  return !(x == y);
}
}

#if !PICOJSON_USE_RVALUE_REFERENCE
namespace std {
template <> inline void swap(picojson::value &x, picojson::value &y) {
  x.swap(y);
}
}
#endif

inline std::istream &operator>>(std::istream &is, picojson::value &x) {
  picojson::set_last_error(std::string());
  const std::string err(picojson::parse(x, is));
  if (!err.empty()) {
    picojson::set_last_error(err);
    is.setstate(std::ios::failbit);
  }
  return is;
}

inline std::ostream &operator<<(std::ostream &os, const picojson::value &x) {
  x.serialize(std::ostream_iterator<char>(os));
  return os;
}
#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif

END --- O:\C++ Programming\GoofyMultiplayerGame\engine\include\picojson.h

--- O:\C++ Programming\GoofyMultiplayerGame\networking\net_common.cpp ---
// net_common.cpp

#define ENET_IMPLEMENTATION
#include <enet.h>

// Any other networking-related code you have here
struct CommonNetDemo {
    int version;
};
END --- O:\C++ Programming\GoofyMultiplayerGame\networking\net_common.cpp

--- O:\C++ Programming\GoofyMultiplayerGame\networking\include\net_common.h ---
#define DEFAULT_SERVER_PORT 6777
#define DEFAULT_SERVER_ADDRESS "127.0.0.1"
END --- O:\C++ Programming\GoofyMultiplayerGame\networking\include\net_common.h

--- O:\C++ Programming\GoofyMultiplayerGame\server\main.cpp ---
#include <enet.h>
#include "engine.h"
#include <iostream>
#include <unordered_map>
#include <vector>
#include <chrono>
#include <thread>

#define SERVER_PORT 6777
#define SLEEP_MS 10

struct PlayerInfo {
    EVec position;
    PlayerColor color;
};

std::unordered_map<ENetPeer*, PlayerInfo> players;  // Map of connected players and their states

ENetHost* server;

void StartServer();
void ProcessPackets();
void StopServer();

int main() {
    StartServer();

    while (true) {
        ProcessPackets();

        ENetEvent event;
        while (enet_host_service(server, &event, 0) > 0) {
            if (event.type == ENET_EVENT_TYPE_CONNECT) {
                char ip[INET6_ADDRSTRLEN];
                enet_address_get_host_ip(&event.peer->address, ip, sizeof(ip));
                std::cout << "A new client connected from " << ip << ":" << event.peer->address.port << std::endl;

                players[event.peer] = PlayerInfo{{960.0f, 540.0f}};  // Start at a default position
            } else if (event.type == ENET_EVENT_TYPE_RECEIVE) {
                if (players.find(event.peer) == players.end()) {
                    // This is the first packet from this client, and it should contain the player's color
                    PlayerColor* receivedColor = (PlayerColor*)event.packet->data;
                    players[event.peer].color = *receivedColor;
                    std::cout << "Received color from client: " << (int)receivedColor->r << ", "
                            << (int)receivedColor->g << ", " << (int)receivedColor->b << std::endl;
                } else {
                    // Handle movement updates
                    EVec* receivedMovementDelta = (EVec*)event.packet->data;
                    PlayerInfo& playerInfo = players[event.peer];
                    playerInfo.position.x += receivedMovementDelta->x;
                    playerInfo.position.y += receivedMovementDelta->y;
                }

                enet_packet_destroy(event.packet);
            } else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {
                std::cout << "Client disconnected." << std::endl;
                players.erase(event.peer);  // Remove the player from the map
            }
        }

        // Broadcast all player positions to all clients
        for (auto& pair : players) {
            ENetPeer* peer = pair.first;
            std::vector<std::pair<EVec, PlayerColor>> playerData;

            for (auto& player : players) {
                playerData.push_back({player.second.position, player.second.color});
            }

            ENetPacket* packet = enet_packet_create(playerData.data(), playerData.size() * sizeof(std::pair<EVec, PlayerColor>), ENET_PACKET_FLAG_RELIABLE);
            enet_peer_send(peer, 0, packet);
        }
    }

    StopServer();
    return 0;
}

void StartServer() {
    if (enet_initialize() != 0) {
        std::cerr << "An error occurred while initializing ENet." << std::endl;
        exit(EXIT_FAILURE);
    }

    ENetAddress address;
    address.host = ENET_HOST_ANY;
    address.port = SERVER_PORT;

    server = enet_host_create(&address, 32, 2, 0, 0);

    if (server == NULL) {
        std::cerr << "An error occurred while trying to create an ENet server host." << std::endl;
        exit(EXIT_FAILURE);
    }

    std::cout << "Server started on port " << SERVER_PORT << "." << std::endl;
}

void StopServer() {
    enet_host_destroy(server);
    enet_deinitialize();
}

void ProcessPackets() {
    std::this_thread::sleep_for(std::chrono::milliseconds(SLEEP_MS));
}

END --- O:\C++ Programming\GoofyMultiplayerGame\server\main.cpp
